const x=globalThis.fetch,y=globalThis.SharedWorker,b=globalThis.localStorage,T=globalThis.navigator.serviceWorker,p=MessagePort.prototype.postMessage,u={CLOSED:WebSocket.CLOSED,CONNECTING:WebSocket.CONNECTING,OPEN:WebSocket.OPEN};async function g(){const e=(await self.clients.matchAll({type:"window",includeUncontrolled:!0})).map((async e=>{const t=await function(e){let t=new MessageChannel;return new Promise((r=>{e.postMessage({type:"getPort",port:t.port2},[t.port2]),t.port1.onmessage=e=>{r(e.data)}}))}(e);return await E(t),t})),t=Promise.race([Promise.any(e),new Promise(((e,t)=>setTimeout(t,1e3,new TypeError("timeout"))))]);try{return await t}catch(e){if(e instanceof AggregateError)throw console.error("bare-mux: failed to get a bare-mux SharedWorker MessagePort as all clients returned an invalid MessagePort."),new Error("All clients returned an invalid MessagePort.");return console.warn("bare-mux: failed to get a bare-mux SharedWorker MessagePort within 1s, retrying"),await g()}}function E(e){const t=new MessageChannel,r=new Promise(((e,r)=>{t.port1.onmessage=t=>{"pong"===t.data.type&&e()},setTimeout(r,1500)}));return p.call(e,{message:{type:"ping"},port:t.port2},[t.port2]),r}function m(e,t){const r=new y(e,"bare-mux-worker");return t&&T.addEventListener("message",(t=>{if("getPort"===t.data.type&&t.data.port){console.debug("bare-mux: recieved request for port from sw");const r=new y(e,"bare-mux-worker");p.call(t.data.port,r.port,[r.port])}})),r.port}let f=null;function C(){if(null===f){const e=new MessageChannel,t=new ReadableStream;let r;try{p.call(e.port1,t,[t]),r=!0}catch{r=!1}return f=r,r}return f}class S{constructor(e){this.channel=new BroadcastChannel("bare-mux"),e instanceof MessagePort||e instanceof Promise?this.port=e:this.createChannel(e,!0)}createChannel(e,t){if(self.clients)this.port=g(),this.channel.onmessage=e=>{"refreshPort"===e.data.type&&(this.port=g())};else if(e&&SharedWorker){if(!e.startsWith("/")&&!e.includes("://"))throw new Error("Invalid URL. Must be absolute or start at the root.");this.port=m(e,t),console.debug("bare-mux: setting localStorage bare-mux-path to",e),b["bare-mux-path"]=e}else{if(!SharedWorker)throw new Error("Unable to get a channel to the SharedWorker.");{const e=b["bare-mux-path"];if(console.debug("bare-mux: got localStorage bare-mux-path:",e),!e)throw new Error("Unable to get bare-mux workerPath from localStorage.");this.port=m(e,t)}}}async sendMessage(e,t){this.port instanceof Promise&&(this.port=await this.port);try{await E(this.port)}catch{return console.warn("bare-mux: Failed to get a ping response from the worker within 1.5s. Assuming port is dead."),this.createChannel(),await this.sendMessage(e,t)}const r=new MessageChannel,a=[r.port2,...t||[]],s=new Promise(((e,t)=>{r.port1.onmessage=r=>{const a=r.data;"error"===a.type?t(a.error):e(a)}}));return p.call(this.port,{message:e,port:r.port2},a),await s}}class P extends EventTarget{constructor(e,t=[],r,a){super(),this.protocols=t,this.readyState=u.CONNECTING,this.url=e.toString(),this.protocols=t;const s=e=>{this.protocols=e,this.readyState=u.OPEN;const t=new Event("open");this.dispatchEvent(t)},o=async e=>{const t=new MessageEvent("message",{data:e});this.dispatchEvent(t)},n=(e,t)=>{this.readyState=u.CLOSED;const r=new CloseEvent("close",{code:e,reason:t});this.dispatchEvent(r)},c=()=>{this.readyState=u.CLOSED;const e=new Event("error");this.dispatchEvent(e)};this.channel=new MessageChannel,this.channel.port1.onmessage=e=>{"open"===e.data.type?s(e.data.args[0]):"message"===e.data.type?o(e.data.args[0]):"close"===e.data.type?n(e.data.args[0],e.data.args[1]):"error"===e.data.type&&c()},r.sendMessage({type:"websocket",websocket:{url:e.toString(),protocols:t,requestHeaders:a,channel:this.channel.port2}},[this.channel.port2])}send(...e){if(this.readyState===u.CONNECTING)throw new DOMException("Failed to execute 'send' on 'WebSocket': Still in CONNECTING state.");let t=e[0];t.buffer&&(t=t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)),p.call(this.channel.port1,{type:"data",data:t},t instanceof ArrayBuffer?[t]:[])}close(e,t){p.call(this.channel.port1,{type:"close",closeCode:e,closeReason:t})}}function k(e,t,r){console.error(`error while processing '${r}': `,t),e.postMessage({type:"error",error:t})}function v(e){for(let t=0;t<e.length;t++){const r=e[t];if(!"!#$%&'*+-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ^_`abcdefghijklmnopqrstuvwxyz|~".includes(r))return!1}return!0}const R=["ws:","wss:"],O=[101,204,205,304],N=[301,302,303,307,308];class W{constructor(e){this.worker=new S(e)}async getTransport(){return(await this.worker.sendMessage({type:"get"})).name}async setTransport(e,t,r){await this.setManualTransport(`\n\t\t\tconst { default: BareTransport } = await import("${e}");\n\t\t\treturn [BareTransport, "${e}"];\n\t\t`,t,r)}async setManualTransport(e,t,r){if("bare-mux-remote"===e)throw new Error("Use setRemoteTransport.");await this.worker.sendMessage({type:"set",client:{function:e,args:t}},r)}async setRemoteTransport(e,t){const r=new MessageChannel;r.port1.onmessage=async t=>{const r=t.data.port,a=t.data.message;if("fetch"===a.type)try{e.ready||await e.init(),await async function(e,t,r){const a=await r.request(new URL(e.fetch.remote),e.fetch.method,e.fetch.body,e.fetch.headers,null);if(!C()&&a.body instanceof ReadableStream){const e=new Response(a.body);a.body=await e.arrayBuffer()}a.body instanceof ReadableStream||a.body instanceof ArrayBuffer?p.call(t,{type:"fetch",fetch:a},[a.body]):p.call(t,{type:"fetch",fetch:a})}(a,r,e)}catch(e){k(r,e,"fetch")}else if("websocket"===a.type)try{e.ready||await e.init(),await async function(e,t,r){const[a,s]=r.connect(new URL(e.websocket.url),e.websocket.protocols,e.websocket.requestHeaders,(t=>{p.call(e.websocket.channel,{type:"open",args:[t]})}),(t=>{t instanceof ArrayBuffer?p.call(e.websocket.channel,{type:"message",args:[t]},[t]):p.call(e.websocket.channel,{type:"message",args:[t]})}),((t,r)=>{p.call(e.websocket.channel,{type:"close",args:[t,r]})}),(t=>{p.call(e.websocket.channel,{type:"error",args:[t]})}));e.websocket.channel.onmessage=e=>{"data"===e.data.type?a(e.data.data):"close"===e.data.type&&s(e.data.closeCode,e.data.closeReason)},p.call(t,{type:"websocket"})}(a,r,e)}catch(e){k(r,e,"websocket")}},await this.worker.sendMessage({type:"set",client:{function:"bare-mux-remote",args:[r.port2,t]}},[r.port2])}getInnerPort(){return this.worker.port}}class L{constructor(e){this.worker=new S(e)}createWebSocket(e,t=[],r,a){try{e=new URL(e)}catch{throw new DOMException(`Faiiled to construct 'WebSocket': The URL '${e}' is invalid.`)}if(!R.includes(e.protocol))throw new DOMException(`Failed to construct 'WebSocket': The URL's scheme must be either 'ws' or 'wss'. '${e.protocol}' is not allowed.`);Array.isArray(t)||(t=[t]),t=t.map(String);for(const e of t)if(!v(e))throw new DOMException(`Failed to construct 'WebSocket': The subprotocol '${e}' is invalid.`);return a=a||{},new P(e,t,this.worker,a)}async fetch(e,t){const r=new Request(e,t),a=t?.headers||r.headers,s=a instanceof Headers?Object.fromEntries(a):a,o=r.body;let n=new URL(r.url);if(n.protocol.startsWith("blob:")){const e=await x(n),t=new Response(e.body,e);return t.rawHeaders=Object.fromEntries(e.headers),t}for(let e=0;;e++){let a=(await this.worker.sendMessage({type:"fetch",fetch:{remote:n.toString(),method:r.method,headers:s,body:o||void 0}},o?[o]:[])).fetch,c=new Response(O.includes(a.status)?void 0:a.body,{headers:new Headers(a.headers),status:a.status,statusText:a.statusText});c.rawHeaders=a.headers,c.rawResponse=a,c.finalURL=n.toString();const i=t?.redirect||r.redirect;if(!N.includes(c.status))return c;switch(i){case"follow":{const t=c.headers.get("location");if(20>e&&null!==t){n=new URL(t,n);continue}throw new TypeError("Failed to fetch")}case"error":throw new TypeError("Failed to fetch");case"manual":return c}}}}console.debug("bare-mux: running v2.1.7 (build c56d286)");export{L as k,W as m};